/*
 * (c) 2021 Ben Stragnell
 */

#include "rmiieth.h"
#include "rmiieth_md.h"
#include "pkt_utils.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include <stdio.h>
#include <stdlib.h>
#include "lwip/opt.h"
#include "lwip/def.h"
#include "lwip/mem.h"
#include "lwip/pbuf.h"
#include "lwip/stats.h"
#include "lwip/snmp.h"
#include "lwip/ethip6.h"
#include "lwip/etharp.h"
#include "lwip/dhcp.h"
#include "lwip/init.h"
#include "lwip/netif.h"
#include "lwip/netifapi.h"
#include "lwip/ip_addr.h"
#include "lwip/acd.h"
#include "netif/ethernet.h"
#include "lwip/opt.h"
#include "lwip/timeouts.h"
#include "lwip/apps/httpd.h"
#include "pkt_utils.h"
#include <string.h>

#define IFNAME0 'b'
#define IFNAME1 'b'

static uint8_t g_fake_mac[ 6 ] = {
    0xa4,0xdd,0x7b,0xb6,0xf2,0x1d
};



struct ethernetif {
    rmiieth_config* rmiieth_cfg;
};

static void ethernetif_input(struct netif *netif);

static void low_level_init(struct netif *netif)
{
    struct ethernetif *ethernetif = netif->state;
    struct pbuf *q;
    rmiieth_config* cfg = (rmiieth_config*)ethernetif->rmiieth_cfg;

    netif->hwaddr_len = ETHARP_HWADDR_LEN;
    for( int i = 0 ; i < 6 ; i++ )
    {
        netif->hwaddr[ i ] = g_fake_mac[ i ];
    }
    netif->mtu = cfg->mtu;
    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
}

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
    struct ethernetif *ethernetif = netif->state;
    struct pbuf *q;
    rmiieth_config* cfg = (rmiieth_config*)ethernetif->rmiieth_cfg;

#if ETH_PAD_SIZE
    pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */
#endif

    //
    // compute required size
    //

    int cc_len = 0;
    for( q = p; q != NULL; q = q->next )
    {
        cc_len += q->len;
    }
    cc_len += 8;      // preamble
    cc_len += 4;
    if( cc_len < 72 ) // min length = 8 + 60 + 4 = 72
    {
        cc_len = 72;
    }

    //
    // allocate packet
    //

    uint8_t*    tx_buffer;
    int32_t     tx_len = 0;

    if( !rmiieth_tx_alloc_packet( cfg, cc_len, &tx_buffer) )
    {
        return( ERR_OK );           /// ?
    }

    //
    // construct TX packet, including preamble and fcs
    //

    tx_buffer[ tx_len++ ] = 0x55;  tx_buffer[ tx_len++ ] = 0x55;  tx_buffer[ tx_len++ ] = 0x55;  tx_buffer[ tx_len++ ] = 0x55;
    tx_buffer[ tx_len++ ] = 0x55;  tx_buffer[ tx_len++ ] = 0x55;  tx_buffer[ tx_len++ ] = 0x55;  tx_buffer[ tx_len++ ] = 0xd5;
    for( q = p; q != NULL; q = q->next )
    {
        memcpy( &tx_buffer[ tx_len ], q->payload, q->len );
        tx_len += q->len;
    }
    while( tx_len < 8 + 64 - 4 )
    {
        tx_buffer[ tx_len++ ] = 0x00;
    }
    uint32_t fcs = pkt_generate_fcs( &tx_buffer[ 8 ], tx_len - 8 );
    tx_buffer[ tx_len++ ] = (uint8_t)( fcs >>  0 );
    tx_buffer[ tx_len++ ] = (uint8_t)( fcs >>  8 );
    tx_buffer[ tx_len++ ] = (uint8_t)( fcs >> 16 );
    tx_buffer[ tx_len++ ] = (uint8_t)( fcs >> 24 );

    assert( cc_len == tx_len );

    rmiieth_tx_commit_packet( cfg, tx_len );

    MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p->tot_len);
    if (((u8_t *)p->payload)[0] & 1) {
        /* broadcast or multicast packet*/
        MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
    } else {
        /* unicast packet */
        MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
    }
    /* increase ifoutdiscards or ifouterrors on error */

#if ETH_PAD_SIZE
    pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

    LINK_STATS_INC(link.xmit);

    return ERR_OK;
}



static struct pbuf *low_level_input(struct netif *netif)
{
    struct ethernetif *ethernetif = netif->state;
    rmiieth_config* cfg = ethernetif->rmiieth_cfg;
    struct pbuf *p = NULL;
    struct pbuf *q;
    uint8_t*    pkt;
    int         pkt_len;

    if( !rmiieth_rx_get_packet( cfg, &pkt, &pkt_len ) )
    {
        return( NULL );
    }

    if( !pkt_validate( pkt, &pkt_len ) )
    {
        LINK_STATS_INC(link.drop);
        MIB2_STATS_NETIF_INC(netif, ifindiscards);
        rmiieth_rx_consume_packet( cfg );
        return( NULL );
    }

    p = pbuf_alloc(PBUF_RAW, pkt_len, PBUF_POOL);
    if( !p )
    {
        rmiieth_rx_consume_packet( cfg );
        return( NULL );
    }

    // we're good
    int pos = 0;
    for( q = p; q != NULL; q = q->next )
    {
        memcpy( q->payload, &pkt[ pos ], q->len );
        pos += q->len;
    }

    MIB2_STATS_NETIF_ADD(netif, ifinoctets, p->tot_len);
    if (((u8_t *)p->payload)[0] & 1) {
        MIB2_STATS_NETIF_INC(netif, ifinnucastpkts);
    } else {
        MIB2_STATS_NETIF_INC(netif, ifinucastpkts);
    }
    LINK_STATS_INC(link.recv);
    rmiieth_rx_consume_packet( cfg );
    return p;
}

static void ethernetif_input(struct netif *netif)
{
  struct ethernetif *ethernetif;
  struct eth_hdr *ethhdr;
  struct pbuf *p;

  ethernetif = netif->state;

  p = low_level_input(netif);
  if (p != NULL) {
    if (netif->input(p, netif) != ERR_OK) {
      LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
      pbuf_free(p);
      p = NULL;
    }
  }
}


err_t ethernetif_init(struct netif *netif)
{
  struct ethernetif *ethernetif;

  LWIP_ASSERT("netif != NULL", (netif != NULL));

#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  /*
   * Initialize the snmp variables and counters inside the struct netif.
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  MIB2_INIT_NETIF(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

  netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
  /* We directly use etharp_output() here to sethernetifave a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
#if LWIP_IPV4
  netif->output = etharp_output;
#endif /* LWIP_IPV4 */
#if LWIP_IPV6
  netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */
  netif->linkoutput = low_level_output;

//  ethernetif->ethaddr = (struct eth_addr *) & (netif->hwaddr[0]);

  /* initialize the hardware */
  low_level_init(netif);

  return ERR_OK;
}


//
//
//
//
//



void rmiieth_lwip_poll( struct netif* netif )
{
    struct ethernetif* ethernetif = netif->state;
    rmiieth_config* cfg = ethernetif->rmiieth_cfg;

    rmiieth_poll( cfg );
    while( rmiieth_rx_packet_available( cfg ) )
    {
        ethernetif_input( netif );
    }
}



void main_lwip( rmiieth_config* cfg )
{
    int rc;
    static struct netif rmiieth_netif;
    static struct ethernetif rmiieth_ethernetif;
    struct netif* nif;

    lwip_init();


    memset( &rmiieth_ethernetif, 0, sizeof( rmiieth_ethernetif ) );
    rmiieth_ethernetif.rmiieth_cfg = cfg;
    rmiieth_netif.state = &rmiieth_ethernetif;
    nif = netif_add_noaddr( &rmiieth_netif, &rmiieth_ethernetif, ethernetif_init, ethernet_input );


    netif_set_up( &rmiieth_netif );
    netif_set_link_up( &rmiieth_netif );
    rc = dhcp_start( &rmiieth_netif );

    httpd_init();

    while( true )
    {
        sleep_us( 1 );
        sys_check_timeouts();
        rmiieth_lwip_poll( nif );

        if( false )
        {
            static int ctr = 0;
            if( !(( ctr++ ) & 255 ) )
            {
                uint32_t v = rmiieth_md_readreg( cfg, RMII_REG_BASIC_STATUS );
                printf( "%08x\n", v );
            }
        }

    }

}




#include "pkt_queue.h"

static uint8_t dhcp_pkt[] = {
0x55,0x55,0x55,0x55,0x55,0x55,0x55,0xd5,0xff,0xff,0xff,0xff,0xff,0xff,0xa4,0xdd,
0x7b,0xb6,0xf2,0x1d,0x08,0x00,0x45,0x00,0x01,0x50,0x00,0x00,0x00,0x00,0xff,0x11,
0xba,0x9d,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x44,0x00,0x43,0x01,0x3c,
0x66,0xf3,0x01,0x01,0x06,0x00,0xab,0xcd,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa4,0xdd,
0x7b,0xb6,0xf2,0x1d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x82,
0x53,0x63,0x35,0x01,0x01,0x39,0x02,0x05,0xdc,0x37,0x03,0x01,0x03,0x1c,0xff,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xa1,0x53,0x28,0x67
};
static uint8_t icmp_pkt[] = {
0x55,0x55,0x55,0x55,0x55,0x55,0x55,0xd5,0xa4,0xbb,0x6d,0xd8,0xf4,0x7b,0xa4,0xdd,
0x7b,0xb6,0xf2,0x1d,0x08,0x00,0x45,0x00,0x00,0x54,0x76,0xfa,0x40,0x00,0xff,0x01,
0xee,0xb4,0x0a,0x64,0x00,0xc5,0x0a,0x64,0x00,0x6d,0x00,0x00,0xef,0x37,0x00,0x4d,
0x03,0xb6,0x48,0xcb,0x5b,0x60,0x00,0x00,0x00,0x00,0xa9,0xc6,0x00,0x00,0x00,0x00,
0x00,0x00,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,
0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,
0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x55,0x2e,0x74,0xcb
};
static uint8_t icmp_big_pkt[] = {
0x55,0x55,0x55,0x55,0x55,0x55,0x55,0xd5,
0xa4,0xbb,0x6d,0xd8,0xf4,0x7b,0xa4,0xdd,0x7b,0xb6,0xf2,0x1d,0x08,0x00,0x45,0x00,
0x04,0x04,0xc9,0xb4,0x40,0x00,0xff,0x01,0x98,0x4a,0x0a,0x64,0x00,0xc5,0x0a,0x64,
0x00,0x6d,0x00,0x00,0xcd,0xe7,0x00,0x8b,0x00,0x15,0x8f,0x42,0x5e,0x60,0x00,0x00,
0x00,0x00,0xdc,0x91,0x0e,0x00,0x00,0x00,0x00,0x00,0x10,0x11,0x12,0x13,0x14,0x15,
0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,
0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,
0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,
0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,
0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,
0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,
0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,
0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,
0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,
0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,
0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,
0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,
0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,
0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,
0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x00,0x01,0x02,0x03,0x04,0x05,
0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,
0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,
0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,
0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,
0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,
0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,
0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,
0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,
0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,
0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,
0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,
0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,
0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,
0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,
0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,
0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x00,0x01,0x02,0x03,0x04,0x05,
0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,
0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,
0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,
0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,
0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,
0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,
0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,
0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,
0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,
0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,
0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,
0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,
0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,
0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,
0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,
0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x00,0x01,0x02,0x03,0x04,0x05,
0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,
0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,
0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,
0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,
0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,
0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,
0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,
0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,
0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,
0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,
0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,
0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,
0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,
0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,
0xe6,0xe7,0x79,0xfe,0x62,0x14
};


int main( int argc, char** argv )
{
    rmiieth_config     rmii_cfg;

    //
    // set system clock
    //

    set_sys_clock_khz( 250000, false );
    setup_default_uart();
    printf( "hello world\n" );

    //
    // init rmiieth interface
    //

    rmiieth_set_default_config( &rmii_cfg );
    rmiieth_init( &rmii_cfg );
    if( !rmiieth_probe( &rmii_cfg ) )
    {
        assert( false );
    }
//    rmii_cfg.rx_irq = 1;
    sleep_ms( 500 );
    rmiieth_md_reset( &rmii_cfg );
    sleep_ms( 500 );

    //
    // select 100Mbit ethernet, duplex, autonegotiation
    //

#if 1
    //  basic control:          0011 0011 0000 0000         enable auto-neg, restart auto-neg
    //  autoneg-advert:         0000 0001 1000 0001         100Mbps, full duplex

    uint32_t basic_control = 0x3300;
    rmiieth_md_writereg( &rmii_cfg, RMII_REG_AUTONEG_ADVERT, 0x181 );
    rmiieth_md_writereg( &rmii_cfg, RMII_REG_BASIC_CONTROL, basic_control );
#else
    //  basic control:          0010 0001 0000 0000
    uint32_t basic_control = 0x2100;
    rmiieth_md_writereg( &rmii_cfg, RMII_REG_BASIC_CONTROL, basic_control );
#endif    
    sleep_ms( 500 );

    //
    // tx test - send a packet repeatedly
    //

#if 0
    while( true )
    {
        static int send_delay = 0;
        sleep_ms( 1 );

        rmiieth_config* cfg = &rmii_cfg;
        rmiieth_poll( cfg );
        if( !cfg->tx_current_pkt )
        {
            if( send_delay )
            {
                send_delay -= 1;
            }
            else
            {
#define SEND_PKT icmp_big_pkt                
                send_delay = 1;
                printf( "sending...\n" );
                uint8_t*            pkt_data;
                if( rmiieth_tx_alloc_packet( cfg, sizeof( SEND_PKT ), &pkt_data ) )
                {
                    memcpy( pkt_data, SEND_PKT, sizeof( SEND_PKT) );
                    rmiieth_tx_commit_packet( cfg, sizeof( SEND_PKT ) );
                }
            }
        }
        
        while( rmiieth_rx_packet_available( cfg) )
        {
            uint8_t*            pkt;
            int                 pkt_len;
            if( rmiieth_rx_get_packet( cfg, &pkt, &pkt_len ) )
            {
                if( pkt_validate( pkt, &pkt_len ) )
                {
                    printf( "I GOT A PACKET\n" );
                }            
                rmiieth_rx_consume_packet( cfg );
            }
        }
    }
#endif    

    //
    // lwip startup
    //

    if( true )
    {
        main_lwip( &rmii_cfg );
    }


    while( true )
    {
        rmiieth_config* cfg = &rmii_cfg;

        sleep_ms( 10 );
        uint32_t v = rmiieth_md_readreg( &rmii_cfg, RMII_REG_BASIC_STATUS );
        printf( "%08x\n", v );

        // 78 = 01111000
        //  0   no 100base-t4
        //  1   100base-tx full duplex
        //  1   100base-tx half duplex
        //  1   10base-t full duplex
        //  1   10base-t half duplex
        //  0   no 100base-t2 full duplex
        //  0   no 100base-t2 half duplex
        //  0   no extended status information

        // 09 = 00001001
        //  0   reserved
        //  0   reserved
        //  0   auto-negotiate not complete
        //  0   no remote fault
        //  1   able to perform autonegotiate
        //  0   link down
        //  0   no jabber
        //  1   supports extended capabilities
        
        // 2d = 00101101
        //  0   reserved
        //  0   reserved
        //  1   auto-negotiate complete
        //  0   no remote fault
        //  1   able to perform autonegotiate
        //  1   link up
        //  0   no jabber
        //  1   supports extended capabilities

        //
        // dump packets
        //

        if( true )
        {
            uint8_t*        pkt_data;
            int             pkt_length;

            rmiieth_poll( cfg );
            while( rmiieth_rx_get_packet( cfg, &pkt_data, &pkt_length ) )
            {
                printf( ">>> received %d bytes\n", pkt_length );
                if( pkt_validate( pkt_data, &pkt_length ) )
                {
                    printf(" **** VALIDATED\n" );
                    for( int i = 0; i < pkt_length && i < 64 ; i++ )
                    {
                        printf( " %02x", pkt_data[ i ] );
                    }
                    printf( "\n" );
                }
                rmiieth_rx_consume_packet( cfg );
            }
        }
    }

    return( 0 );
}


